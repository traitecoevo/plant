Leaf:
  name_cpp: "plant::Leaf"
  constructor:
    args:
      - vcmax_25: double
      - c: double
      - b: double
      - psi_crit: double
      - beta1: double
      - beta2: double
      - jmax_25: double
      - hk_s: double
      - a: double
      - curv_fact_elec_trans: double
      - curv_fact_colim: double     
      - GSS_tol_abs: double
      - vulnerability_curve_ncontrol: double
      - ci_abs_tol: double
      - ci_niter: double

  active:
    ci_: {type: double, access: field}
    stom_cond_CO2_: {type: double, access: field}
    assim_colimited_: {type: double, access: field}
    transpiration_: {type: double, access: field}
    profit_: {type: double, access: field}
    psi_stem: {type: double, access: field}
    lambda_: {type: double, access: field}
    lambda_analytical_: {type: double, access: field}
    electron_transport_: {type: double, access: field}
    gamma_: {type: double, access: field}
    ko_: {type: double, access: field}
    kc_: {type: double, access: field}
    km_: {type: double, access: field}
    R_d_: {type: double, access: field}
    leaf_specific_conductance_max_: {type: double, access: field}
    vcmax_: {type: double, access: field}
    jmax_: {type: double, access: field}
    rho_: {type: double, access: field}
    a_bio_: {type: double, access: field}
    PPFD_: {type: double, access: field}
    atm_vpd_: {type: double, access: field}
    ca_: {type: double, access: field}
    psi_soil_: {type: double, access: field}
    leaf_temp_: {type: double, access: field} 
    atm_o2_kpa_: {type: double, access: field} 
    atm_kpa_: {type: double, access: field} 
    hydraulic_cost_: {type: double, access: field}
    opt_psi_stem_: {type: double, access: field}
    opt_ci_: {type: double, access: field}
    count: {type: double, access: field}

  methods:
    initialize_integrator:
      return_type: void
      args: [integration_rule: int, integration_tol: double]
    set_physiology:
      return_type: void 
      args: [rho: double, a_bio: double, PPFD: double, psi_soil: double, leaf_specific_conductance_max: double, atm_vpd: double, ca: double, sapwood_volume_per_leaf_area: double, leaf_temp: double, atm_o2_kpa: double, atm_kpa: double]
    #transpiration functions
    proportion_of_conductivity:
      return_type: double
      args: [psi: double]
    arrh_curve:
      return_type: double
      args: [Ea: double, ref_value: double, leaf_temp: double]
    peak_arrh_curve:
      return_type: double
      args: [Ea: double, ref_value: double, leaf_temp: double, H_d: double, d_S: double] 
    transpiration:
      return_type: double
      args: [psi_stem: double]
    transpiration_full_integration:
      return_type: double
      args: [psi_stem: double]
    stom_cond_CO2:
      return_type: double
      args: [psi_stem: double]
    transpiration_to_psi_stem:
      return_type: double
      args: [transpiration_: double]
    # assimilation functions 
    assim_rubisco_limited:
      return_type: double
      args: [ci_: double]
    assim_electron_limited:
      return_type: double
      args: [ci_: double]
    assim_colimited:
      return_type: double
      args: [ci_: double]
    assim_minus_stom_cond_CO2:
      return_type: double
      args: [x: double, psi_stem: double]
    electron_transport:
      return_type: double
      args: []      
    set_leaf_states_rates_from_psi_stem:
      return_type: void
      args: [psi_stem: double]
    psi_stem_to_ci:
      return_type: double
      args: [psi_stem: double]
    #leaf economics functions
    hydraulic_cost_Sperry:
      return_type: double
      args: [psi_stem: double]
    hydraulic_cost_TF:
      return_type: double
      args: [psi_stem: double]
    profit_psi_stem_Sperry:
      return_type: double
      args: [psi_stem: double]
    profit_Sperry_ci:
      return_type: double
      args: [ci_: double] 
    profit_psi_stem_TF:
      return_type: double
      args: [psi_stem: double]
      # optimiser functions
    optimise_psi_stem_Sperry:
      return_type: void
      args: []
    optimise_ci_Sperry:
      return_type: void
      args: [max_ci: double]
    optimise_psi_stem_TF:
      return_type: void
      args: []
      
Lorenz:
  name_cpp: "plant::ode::test::Lorenz"
  constructor:
    args: [sigma: double, R: double, b: double]
  active:
    ode_size: {type: size_t, access: member}
    ode_state: {type: "plant::ode::state_type", access: function, name_cpp: "plant::ode::r_ode_state", name_cpp_set: "plant::ode::r_set_ode_state"}
    ode_rates: {type: "plant::ode::state_type", access: function, name_cpp: "plant::ode::r_ode_rates"}
    pars: {type: "std::vector<double>", access: member}

OdeR:
  name_cpp: "plant::ode::test::OdeR"
  forward_declare: true
  constructor:
    args: [derivs: "Rcpp::Function", state: "Rcpp::Function", time: double]
  methods:
    update_state: {return_type: void}

OdeRunner:
  name_cpp: "plant::ode::Runner<T>"
  templates:
    parameters: T
    concrete:
      - ["Lorenz": "plant::ode::test::Lorenz"]
      - ["OdeR":   "plant::ode::test::OdeR"]
      - ["FF16": "plant::tools::IndividualRunner<plant::FF16_Strategy, plant::FF16_Environment>"]
      - ["TF24": "plant::tools::IndividualRunner<plant::TF24_Strategy, plant::TF24_Environment>"]
      - ["FF16r": "plant::tools::IndividualRunner<plant::FF16r_Strategy, plant::FF16_Environment>"]
      - ["K93": "plant::tools::IndividualRunner<plant::K93_Strategy, plant::K93_Environment>"]
  constructor:
    args: [obj: T, control: "plant::ode::OdeControl=OdeControl()"]
  active:
    time: {type: double, access: member}
    state: {type: "plant::ode::state_type", access: member}
    times: {type: "std::vector<double>", access: member}
    object: {type: T, access: member}
  methods:
    advance: {return_type: void, args: [time: double]}
    advance_fixed: {return_type: void, args: [time: "std::vector<double>"]}
    step: {return_type: void}
    step_to: {return_type: void, args: [time: double]}
    set_state: {return_type: void, args: [y: "plant::ode::state_type", time: double]}
    set_state_from_system: {return_type: void}

NodeScheduleEvent:
  name_cpp: "plant::NodeScheduleEvent"
  constructor:
    args: [introduction: double, species_index: "plant::util::index"]
  active:
    species_index: {type: "plant::util::index", access: field, name_cpp: species_index}
    times: {type: "std::vector<double>", access: field, readonly: true}
    time_introduction: {type: double, access: member}
    time_end: {type: double, access: member}
    species_index_raw: {type: "size_t", access: member, name_cpp: species_index_raw}

NodeSchedule:
  name_cpp: "plant::NodeSchedule"
  constructor:
    roxygen: |
      Schedule of node introduction times
      @param n_species number of species
      @export
    args: [n_species: size_t]
  active:
    size: {type: size_t, access: member}
    n_species: {type: size_t, access: member, name_cpp: get_n_species}
    next_event: {type: "plant::NodeScheduleEvent", access: member}
    remaining: {type: size_t, access: member}
    max_time: {type: double, access: member, name_cpp: get_max_time, name_cpp_set: r_set_max_time}
    ode_times: {type: "std::vector<double>", access: member, name_cpp: r_ode_times, name_cpp_set: r_set_ode_times}
    use_ode_times: {type: bool, access: member, name_cpp: using_ode_times, name_cpp_set: r_set_use_ode_times}
    all_times: {type: SEXP, access: member, name_cpp: r_all_times, name_cpp_set: r_set_all_times}
  methods:
    expand:
      return_type: "plant::NodeSchedule"
      args: [n_extra: size_t, times: "std::vector<double>"]
    clear_times:
      return_type: void
      args: [species_index: "plant::util::index"]
    clear_ode_times:
      return_type: void
      name_cpp: r_clear_ode_times
    set_times:
      return_type: void
      name_cpp: r_set_times
      args: [times: "std::vector<double>", species_index: "plant::util::index"]
    times:
      return_type: "std::vector<double>"
      name_cpp: r_times
      args: [species_index: "plant::util::index"]
    reset:
      return_type: void
    pop:
      return_type: void
    copy:
      return_type: "plant::NodeSchedule"
      name_cpp: r_copy

Control:
  name_cpp: "plant::Control"
  roxygen: |
    Control parameters that tune various aspects of the numerical solvers.
    @title Control parameters
    @param ...,values Values to initialise the struct with (either as
    variadic arguments, or as a list, but not both).
    @export
  list:
    - function_integration_rule: size_t
    - offspring_production_tol: double
    - offspring_production_iterations: int
    - node_gradient_eps: double
    - node_gradient_direction: int
    - node_gradient_richardson: bool
    - node_gradient_richardson_depth: size_t
    - ode_step_size_initial: double
    - ode_step_size_min: double
    - ode_step_size_max: double
    - ode_tol_rel: double
    - ode_tol_abs: double
    - ode_a_y: double
    - ode_a_dydt: double
    - schedule_nsteps: size_t
    - schedule_eps: double
    - schedule_verbose: bool
    - save_RK45_cache: bool
    - GSS_tol_abs: double
    - vulnerability_curve_ncontrol: double
    - ci_abs_tol: double
    - ci_niter: double

OdeControl:
  name_cpp: "plant::ode::OdeControl"
  roxygen: |
    Control parameters for the ode system
    @title ODE Control parameters
    @param ...,values Values to initialise the struct with (either as
    variadic arguments, or as a list, but not both).
    @export
  list:
    - tol_abs: double
    - tol_rel: double
    - a_y: double
    - a_dydt: double
    - step_size_min: double
    - step_size_max: double
    - step_size_initial: double

QK:
  name_cpp: "plant::quadrature::QK"
  constructor:
    roxygen: |
      Gauss-Kronrod Quadrature
      @param rule Degree of the rule; valid sizes are 15, 21, 31, 41, 51, 61.
    args: [rule: size_t]
  methods:
    integrate:
      name_cpp: r_integrate
      args: [f: SEXP, a: double, b: double]
      return_type: double
    integrate_vector_x:
      args: [a: double, b: double]
      return_type: "std::vector<double>"
    integrate_vector:
      args: [y: "std::vector<double>", a: double, b: double]
      return_type: double
  active:
    last_area: {type: double, access: member, name_cpp: get_last_area}
    last_error: {type: double, access: member, name_cpp: get_last_error}
    last_area_abs: {type: double, access: member, name_cpp: get_last_area_abs}
    last_area_asc: {type: double, access: member, name_cpp: get_last_area_asc}

QAG:
  name_cpp: "plant::quadrature::QAG"
  constructor:
    args: [rule: size_t, max_iterations: size_t, atol: double, rtol: double]
  methods:
    integrate:
      return_type: double
      name_cpp: r_integrate
      args: [f: SEXP, a: double, b: double]
    integrate_with_intervals:
      return_type: double
      name_cpp: r_integrate_with_intervals
      args: [f: SEXP, intervals: SEXP]
    integrate_with_last_intervals:
      return_type: double
      name_cpp: r_integrate_with_last_intervals
      args: [f: SEXP, a: double, b: double]
  active:
    last_area: {type: double, access: member, name_cpp: get_last_area}
    last_error: {type: double, access: member, name_cpp: get_last_error}
    last_iterations: {type: size_t, access: member, name_cpp: get_last_iterations}
    last_intervals: {type: "plant::quadrature::intervals_type", access: member, name_cpp: get_last_intervals}
    is_adaptive: {type: bool, access: member}


Interpolator:
  name_cpp: "plant::interpolator::Interpolator"
  constructor:
    roxygen: |
      Spline interpolation
      @export
  methods:
    init:
      return_type: void
      args: [x: "const std::vector<double>&", y: "const std::vector<double>&"]
    eval:
      return_type: "std::vector<double>"
      args: [x: "std::vector<double>"]
      name_cpp: r_eval
    set_extrapolate:
      return_type: void
      args: [e: bool]
  active:
    x: {type: "std::vector<double>", access: member, name_cpp: get_x}
    y: {type: "std::vector<double>", access: member, name_cpp: get_y}
    xy: {type: SEXP, access: member, name_cpp: r_get_xy}
    size: {type: size_t, access: member}
    min: {type: double, access: member}
    max: {type: double, access: member}

Individual:
  name_cpp: "plant::Individual<T,E>"
  templates:
    parameters: [T,E]
    concrete:
      - ["FF16": "plant::FF16_Strategy", "FF16_Env": "plant::FF16_Environment"]
      - ["TF24": "plant::TF24_Strategy", "TF24_Env": "plant::TF24_Environment"]
      - ["FF16r": "plant::FF16r_Strategy", "FF16_Env": "plant::FF16_Environment"]
      - ["K93": "plant::K93_Strategy", "K93_Env": "plant::K93_Environment"]
  constructor:
    args: [s: T]
    name_cpp: "plant::make_individual<T,E>"
    roxygen: |
      Individual object
      @param T String containing class of plant strategy to create;
      @param E String containing class of environmnet to create;
      @export
  active:
    strategy: {type: "T", access: member, name_cpp: r_get_strategy}
    internals: {type: "plant::Internals", access: member, name_cpp: "r_internals"}
    aux_size: {type: size_t, access: member}
    ode_size: {type: size_t, access: member}
    ode_names: {type: "std::vector<std::string>", access: member}
    aux_names: {type: "std::vector<std::string>", access: member}
    ode_state: {type: "plant::ode::state_type", access: function, name_cpp: "plant::ode::r_ode_state", name_cpp_set: "plant::ode::r_set_ode_state"}
    ode_rates: {type: "plant::ode::state_type", access: function, name_cpp: "plant::ode::r_ode_rates"}
    mortality_probability: {type: double, access: member}
    strategy_name: {type: "std::string", access: member}
  methods:
    state:
      args: [name: "std::string"]
      return_type: double
    rate:
      args: [name: "std::string"]
      return_type: double
    aux:
      args: [name: "std::string"]
      return_type: double
    set_state:
      args: [name: "std::string", v: double]
      return_type: void
    compute_competition:
      args: [h: double]
      return_type: double
    compute_rates:
      args: [environment: E]
      return_type: void
    establishment_probability:
      args: [environment: E]
      return_type: double
    net_mass_production_dt:
      args: [environment: E]
      return_type: double
    reset_mortality:
      return_type: void
    resource_compensation_point:
      args: []
      return_type: double

IndividualRunner:
  name_cpp: "plant::tools::IndividualRunner<T,E>"
  templates:
    parameters: [T,E]
    concrete:
      - ["FF16": "plant::FF16_Strategy", "FF16_Env": "plant::FF16_Environment"]
      - ["TF24": "plant::TF24_Strategy", "TF24_Env": "plant::TF24_Environment"]
      - ["FF16r": "plant::FF16r_Strategy", "FF16_Env": "plant::FF16_Environment"]
      - ["K93": "plant::K93_Strategy", "K93_Env": "plant::K93_Environment"]
  constructor:
    name_cpp: "plant::tools::IndividualRunner<T,E>"
    args: [individual: "plant::Individual<T,E>", environment: E]
  active:
    individual: {access: field, type: "plant::Individual<T,E>"}

Internals:
  name_cpp: "plant::Internals"
  constructor:
    args: [s_size: size_t, a_size: size_t]
    roxygen: |
      Internals class holding vectors of states, thier associated rates and auxiliary (aux) state
      which is calculated from the state through running compute_rates
      @title Extract Internals from plant object
      @param s_size ???
      @param a_size ???
      @export
  active:
    state_size: {type: size_t, access: field}
    aux_size: {type: size_t, access: field}
    states: {type: "std::vector<double>", access: field}
    rates: {type: "std::vector<double>", access: field}
    auxs: {type: "std::vector<double>", access: field}
  methods:
    state:
      args: [i: int]
      return_type: double
    rate:
      args: [i: int]
      return_type: double
    aux:
      args: [i: int]
      return_type: double
    set_aux:
      args: [i: int, v: double]
      return_type: void
    set_state:
      args: [i: int, v: double]
      return_type: void
    set_rate:
      args: [i: int, v: double]
      return_type: void
    resize:
      args: [new_size: size_t, new_aux_size: size_t]
      return_type: void


Parameters:
  name_cpp: "plant::Parameters<T,E>"
  templates:
    parameters: [T, E]
    concrete:
      - ["FF16": "plant::FF16_Strategy", "FF16_Env": "plant::FF16_Environment"]
      - ["TF24": "plant::TF24_Strategy", "TF24_Env": "plant::TF24_Environment"]
      - ["FF16r": "plant::FF16r_Strategy", "FF16_Env": "plant::FF16_Environment"]
      - ["K93": "plant::K93_Strategy", "K93_Env": "plant::K93_Environment"]
  validator:
    name_cpp: validate
  list:
    - patch_area: double
    - n_patches: size_t
    - patch_type: "std::string"
    - max_patch_lifetime: double
    - strategies: "std::vector<T>"
    - strategy_default: "T"
    - node_schedule_times_default: "std::vector<double>"
    - node_schedule_times: "std::vector<std::vector<double> >"
    - node_schedule_ode_times: "std::vector<double>"

Node:
  name_cpp: "plant::Node<T,E>"
  templates:
    parameters: [T,E]
    concrete:
      - ["FF16": "plant::FF16_Strategy", "FF16_Env": "plant::FF16_Environment"]
      - ["TF24": "plant::TF24_Strategy", "TF24_Env": "plant::TF24_Environment"]
      - ["FF16r": "plant::FF16r_Strategy", "FF16_Env": "plant::FF16_Environment"]
      - ["K93": "plant::K93_Strategy", "K93_Env": "plant::K93_Environment"]
  constructor:
    name_cpp: "plant::make_node<T,E>"
    args: [strategy: T]
  active:
    individual: {type: "plant::Individual<T,E>", access: field, readonly: true}
    height: {type: double, access: member}
    log_density: {type: double, access: member, name_cpp: get_log_density}
    competition_effect: {type: double, access: member}
    fecundity: {type: double, access: member}
    ode_size: {type: size_t, access: member}
    ode_state: {type: "plant::ode::state_type", access: function, name_cpp: "plant::ode::r_ode_state", name_cpp_set: "plant::ode::r_set_ode_state"}
    ode_rates: {type: "plant::ode::state_type", access: function, name_cpp: "plant::ode::r_ode_rates"}
    ode_names: {type: "std::vector<std::string>", access: member}
  methods:
    compute_competition:
      return_type: double
      args: [height: double]
    growth_rate_gradient:
      return_type: double
      name_cpp: "r_growth_rate_gradient"
      args: [environment: E]
    compute_rates:
      return_type: void
      args: [environment: E, pr_patch_survival: double]
    compute_initial_conditions:
      return_type: void
      args: [environment: E, pr_patch_survival: double, birth_rate: double]

# For now, also not templated
Species:
  name_cpp: "plant::Species<T,E>"
  templates:
    parameters: [T,E]
    concrete:
      - ["FF16": "plant::FF16_Strategy", "FF16_Env": "plant::FF16_Environment"]
      - ["TF24": "plant::TF24_Strategy", "TF24_Env": "plant::TF24_Environment"]
      - ["FF16r": "plant::FF16r_Strategy", "FF16_Env": "plant::FF16_Environment"]
      - ["K93": "plant::K93_Strategy", "K93_Env": "plant::K93_Environment"]
  constructor:
    args: [strategy: T]
  active:
    size: {type: size_t, access: member}
    new_node: {type: "plant::Node<T,E>", access: member, name_cpp: r_new_node}
    height_max: {type: double, access: member, readonly: true}
    heights: {type: "std::vector<double>", access: member, name_cpp: r_heights, name_cpp_set: r_set_heights}
    log_densities: {type: "std::vector<double>", access: member, name_cpp: r_log_densities}
    nodes: {type: "std::vector<plant::Node<T,E> >", access: member, name_cpp: r_nodes}
    net_reproduction_ratio_by_node: {type: "std::vector<double>", access: member}
    competition_effects: {type: "std::vector<double>", access: member, name_cpp: r_competition_effects}
    extrinsic_drivers: {type: "plant::ExtrinsicDrivers", access: member, name_cpp: extrinsic_drivers}
    ## ODE interface:
    ode_size: {type: size_t, access: member}
    ode_state: {type: "plant::ode::state_type", access: function, name_cpp: "plant::ode::r_ode_state", name_cpp_set: "plant::ode::r_set_ode_state"}
    ode_rates: {type: "plant::ode::state_type", access: function, name_cpp: "plant::ode::r_ode_rates"}
  methods:
    clear:
      return_type: void
    compute_rates:
      return_type: void
      args: [environment: E, pr_patch_survival: double, birth_rate: double]
    compute_competition:
      return_type: double
      args: [height: double]
    introduce_new_node:
      return_type: void
    node_at:
      return_type: "plant::Node<T,E>"
      args: [index: "plant::util::index"]
      name_cpp: r_node_at
    competition_effects_error:
      return_type: "std::vector<double>"
      args: [scal: double=1]
      name_cpp: r_competition_effects_error

Patch:
  name_cpp: "plant::Patch<T,E>"
  templates:
    parameters: [T, E]
    concrete:
      - ["FF16": "plant::FF16_Strategy", "FF16_Env": "plant::FF16_Environment"]
      - ["TF24": "plant::TF24_Strategy", "TF24_Env": "plant::TF24_Environment"]
      - ["FF16r": "plant::FF16r_Strategy", "FF16_Env": "plant::FF16_Environment"]
      - ["K93": "plant::K93_Strategy", "K93_Env": "plant::K93_Environment"]
  constructor:
    args:
      - parameters: "plant::Parameters<T,E>"
      - environment: "E"
      - control: "plant::Control"
  active:
    time: {type: double, access: member}
    size: {type: size_t, access: member}
    height_max: {type: double, access: member}
    parameters: {type: "plant::Parameters<T,E>", access: member, name_cpp: r_parameters}
    environment: {type: E, access: member, name_cpp: r_environment}
    species: {type: "std::vector<plant::Species<T,E> >", access: member, name_cpp: r_species}
    ## ODE interface:
    ode_size: {type: size_t, access: member}
    ode_time: {type: double, access: function, name_cpp: "plant::ode::r_ode_time"}
    ode_state: {type: "plant::ode::state_type", access: function, name_cpp: "plant::ode::r_ode_state"}
    ode_rates: {type: "plant::ode::state_type", access: function, name_cpp: "plant::ode::r_ode_rates"}
    ode_aux: {type: "plant::ode::state_type", access: function, name_cpp: "plant::ode::r_ode_aux"}
    node_ode_size: {type: size_t, access: member}
  methods:
    introduce_new_node:
      return_type: void
      args: [species_index: "plant::util::index"]
      name_cpp: r_introduce_new_node
    compute_environment:
      return_type: void
      name_cpp: r_compute_environment
    compute_rates:
      return_type: void
      name_cpp: r_compute_rates
    reset:
      return_type: void
    # Because we now care about time, we need to make sure that the
    # setter function passes time along, so can't be done via the
    # active binding (unlike Species, Node, etc).
    set_ode_state:
      return_type: void
      access: function
      name_cpp: "plant::ode::r_set_ode_state"
      args: [values: "plant::ode::state_type", time: double]
    derivs:
      return_type: "plant::ode::state_type"
      access: function
      name_cpp: "plant::ode::r_derivs"
      args: [y: "const plant::ode::state_type&", time: double]
    set_time:
      args: [time: double]
      name_cpp: r_set_time
      return_type: void
    set_state:
      args: [time: double, state: "const std::vector<double>&", n: "const std::vector<size_t>&", env: "const std::vector<double>&"]
      name_cpp: r_set_state
      return_type: void
    # Disturbance interface
    density: {return_type: "std::vector<double>", args: [time: "std::vector<double>"], name_cpp: r_density}
    pr_survival: {return_type: double, args: [time: double], name_cpp: r_pr_survival}
    disturbance_mean_interval: {return_type: double, name_cpp: r_disturbance_mean_interval}
    survival_weighting_cdf: {return_type: double, args: [time: double], name_cpp: r_survival_weighting_cdf}
    survival_weighting_icdf: {return_type: double, args: [prob: double], name_cpp: r_survival_weighting_icdf}
    compute_competition: {return_type: double, args: [height: double]}

SCM:
  name_cpp: "plant::SCM<T,E>"
  templates:
    parameters: [T, E]
    concrete:
      - ["FF16": "plant::FF16_Strategy", "FF16_Env": "plant::FF16_Environment"]
      - ["TF24": "plant::TF24_Strategy", "TF24_Env": "plant::TF24_Environment"]
      - ["FF16r": "plant::FF16r_Strategy", "FF16_Env": "plant::FF16_Environment"]
      - ["K93": "plant::K93_Strategy", "K93_Env": "plant::K93_Environment"]
  constructor:
    args:
      - parameters: "plant::Parameters<T,E>"
      - environment: "E"
      - control: "plant::Control"
  methods:
    run:
      return_type: void
    run_mutant:
      args: [p: "plant::Parameters<T,E>"]
      return_type: void
    run_next:
      return_type: "std::vector<plant::util::index>"
      name_cpp: r_run_next
    reset:
      return_type: void
    net_reproduction_ratio_for_species:
      args: [species_index: "plant::util::index"]
      return_type: double
      name_cpp: r_net_reproduction_ratio_for_species
    competition_effect_error:
      args: [species_index: "plant::util::index"]
      return_type: "std::vector<double>"
      name_cpp: r_competition_effect_error
    set_node_schedule_times:
      args: [times: "std::vector<std::vector<double>>"]
      return_type: void
      name_cpp: r_set_node_schedule_times
    # times
    # set_times
  active:
    complete: {type: bool, access: member}
    time: {type: double, access: member}
    net_reproduction_ratios: {type: "std::vector<double>", access: member}
    offspring_production: {type: "std::vector<double>", access: member}
    parameters: {type: "plant::Parameters<T,E>", access: member, name_cpp: r_parameters}
    patch:
      type: "plant::Patch<T,E>"
      access: member
      name_cpp: r_patch
    node_schedule:
      type: "plant::NodeSchedule"
      access: member
      name_cpp: r_node_schedule
      name_cpp_set: r_set_node_schedule
    ode_times:
      type: "std::vector<double>"
      access: member
      name_cpp: r_ode_times
    state:
      type: "Rcpp::List"
      access: function
      name_cpp: "plant::get_state"
    aux:
      type: "Rcpp::List"
      access: function
      name_cpp: "plant::get_aux"
    use_ode_times:
      type: bool
      access: member
      name_cpp: r_use_ode_times
      name_cpp_set: r_set_use_ode_times
    net_reproduction_ratio_errors:
      type: "std::vector<std::vector<double>>"
      access: member
      name_cpp: r_net_reproduction_ratio_errors


StochasticSpecies:
  name_cpp: "plant::StochasticSpecies<T,E>"
  templates:
    parameters: [T,E]
    concrete:
      - ["FF16": "plant::FF16_Strategy", "FF16_Env": "plant::FF16_Environment"]
      - ["TF24": "plant::TF24_Strategy", "TF24_Env": "plant::TF24_Environment"]
      - ["FF16r": "plant::FF16r_Strategy", "FF16_Env": "plant::FF16_Environment"]
      - ["K93": "plant::K93_Strategy", "K93_Env": "plant::K93_Environment"]
  constructor:
    args: [strategy: "T"]
  active:
    size: {type: size_t, access: member}
    size_individuals: {type: size_t, access: member}
    new_node: {type: "plant::Individual<T,E>", access: member, name_cpp: r_new_node}
    height_max: {type: double, access: member, readonly: true}
    heights: {type: "std::vector<double>", access: member, name_cpp: r_heights, name_cpp_set: r_set_heights}
    individuals: {type: "std::vector<plant::Individual<T,E> >", access: member, name_cpp: r_individuals}
    is_alive: {type: "std::vector<bool>", access: member, name_cpp: r_is_alive}
    net_reproduction_ratio_by_node: {type: "std::vector<double>", access: member}
    ## ODE interface:
    ode_size: {type: size_t, access: member}
    ode_state: {type: "plant::ode::state_type", access: function, name_cpp: "plant::ode::r_ode_state", name_cpp_set: "plant::ode::r_set_ode_state"}
    ode_rates: {type: "plant::ode::state_type", access: function, name_cpp: "plant::ode::r_ode_rates"}
  methods:
    clear:
      return_type: void
    compute_rates:
      return_type: void
      args: [environment: E]
    compute_competition:
      return_type: double
      args: [height: double]
    introduce_new_node:
      return_type: void
    individual_at:
      return_type: "plant::Individual<T,E>"
      args: [index: "plant::util::index"]
      name_cpp: r_individual_at
    deaths:
      return_type: size_t
    establishment_probability:
      args: [environment: E]
      return_type: double

StochasticPatch:
  name_cpp: "plant::StochasticPatch<T,E>"
  templates:
    parameters: [T,E]
    concrete:
      - ["FF16": "plant::FF16_Strategy", "FF16_Env": "plant::FF16_Environment"]
      - ["TF24": "plant::TF24_Strategy", "TF24_Env": "plant::TF24_Environment"]
      - ["FF16r": "plant::FF16r_Strategy", "FF16_Env": "plant::FF16_Environment"]
      - ["K93": "plant::K93_Strategy", "K93_Env": "plant::K93_Environment"]
  constructor:
    args:
      - parameters: "plant::Parameters<T,E>"
      - environment: "E"
      - control: "plant::Control"
  active:
    time: {type: double, access: member}
    size: {type: size_t, access: member}
    height_max: {type: double, access: member}
    parameters: {type: "plant::Parameters<T,E>", access: member, name_cpp: r_parameters}
    environment: {type: E, access: member, name_cpp: r_environment}
    species: {type: "std::vector<plant::StochasticSpecies<T,E> >", access: member, name_cpp: r_species}
    ## ODE interface:
    ode_size: {type: size_t, access: member}
    ode_time: {type: double, access: function, name_cpp: "plant::ode::r_ode_time"}
    ode_state: {type: "plant::ode::state_type", access: function, name_cpp: "plant::ode::r_ode_state"}
    ode_rates: {type: "plant::ode::state_type", access: function, name_cpp: "plant::ode::r_ode_rates"}
  methods:
    compute_competition: {return_type: double, args: [height: double]}
    introduce_new_node:
      return_type: bool
      args: [species_index: "plant::util::index"]
      name_cpp: r_introduce_new_node
    introduce_new_node_and_update:
      return_type: void
      args: [species_index: "plant::util::index"]
      name_cpp: r_introduce_new_node_and_update
    compute_environment:
      return_type: void
      name_cpp: r_compute_environment
    compute_rates:
      return_type: void
      name_cpp: r_compute_rates
    # TODO: Not 100% sure this is needed from R:
    reset:
      return_type: void
    # Because we now care about time, we need to make sure that the
    # setter function passes time along, so can't be done via the
    # active binding (unlike Species, Node, etc).
    set_ode_state:
      return_type: void
      access: function
      name_cpp: "plant::ode::r_set_ode_state"
      args: [values: "plant::ode::state_type", time: double]
    derivs:
      return_type: "plant::ode::state_type"
      access: function
      name_cpp: "plant::ode::r_derivs"
      args: [y: "const plant::ode::state_type&", time: double]
    set_state:
      args: [time: double, state: "const std::vector<double>&", n: "const std::vector<size_t>&"]
      name_cpp: r_set_state
      return_type: void
    deaths:
      return_type: "std::vector<size_t>"

StochasticPatchRunner:
  name_cpp: "plant::StochasticPatchRunner<T,E>"
  templates:
    parameters: [T,E]
    concrete:
      - ["FF16": "plant::FF16_Strategy", "FF16_Env": "plant::FF16_Environment"]
      - ["TF24": "plant::TF24_Strategy", "TF24_Env": "plant::TF24_Environment"]
      - ["FF16r": "plant::FF16r_Strategy", "FF16_Env": "plant::FF16_Environment"]
      - ["K93": "plant::K93_Strategy", "K93_Env": "plant::K93_Environment"]
  constructor:
    args:
      - parameters: "plant::Parameters<T,E>"
      - environment: "E"
      - control: "plant::Control"
  methods:
    run:
      return_type: void
    run_next:
      return_type: "plant::util::index"
      name_cpp: r_run_next
    reset:
      return_type: void
    set_schedule_times:
      args: [times: "std::vector<std::vector<double> >"]
      return_type: void
      name_cpp: r_set_schedule_times
  active:
    complete: {type: bool, access: member}
    time: {type: double, access: member}
    parameters: {type: "plant::Parameters<T,E>", access: member, name_cpp: r_parameters}
    patch:
      type: "plant::StochasticPatch<T,E>"
      access: member
      name_cpp: r_patch
    schedule:
      type: "plant::NodeSchedule"
      access: member
      name_cpp: r_schedule
      name_cpp_set: r_set_schedule
    state:
      type: "Rcpp::List"
      access: function
      name_cpp: "plant::get_state"

ResourceSpline:
  name_cpp: "plant::ResourceSpline"
  constructor:
    args:
      - tol: double
      - nbase: double
      - max_depth: double
      - rescale_usually: bool
  methods:
    get_value_at_height:
      args: [height: double]
      return_type: double
    clear:
      return_type: void
  active:
    spline: {type: "plant::interpolator::Interpolator", access: field}

Disturbance_Regime:
  name_cpp: "plant::Disturbance_Regime"
  constructor:
    roxygen: |
      Base class of representing patch disturbance
      @title Disturbance regime
      @export
  methods:
    density:
      args: [time: "std::vector<double>"]
      return_type: "std::vector<double>"
      name_cpp: r_density
    pr_survival:
      args: [time: double]
      return_type: double

No_Disturbance:
  name_cpp: "plant::No_Disturbance"
  constructor:
    roxygen: |
      A disturbance-free regime for running individual patches
      @title No disturbance regime
      No_Disturbance_Regime control object
      @export
  methods:
    density:
      args: [time: "std::vector<double>"]
      return_type: "std::vector<double>"
      name_cpp: r_density
    pr_survival:
      args: [time: double]
      return_type: double

Weibull_Disturbance_Regime:
  name_cpp: "plant::Weibull_Disturbance_Regime"
  constructor:
    args: [max_patch_lifetime: double]
    roxygen: |
      Weibull_Disturbance_Regime control object.
      @title Weibull disturbance regime
      The frequency of disturbance in a meta-population of patches follows a Weibull distribution
      @param max_patch_lifetime Maximum lifetime of a patch, determines length of a simulation
      @export
  methods:
    density:
      args: [time: "std::vector<double>"]
      return_type: "std::vector<double>"
      name_cpp: r_density
    pr_survival:
      args: [time: double]
      return_type: double
    mean_interval:
      return_type: double
      name_cpp: r_mean_interval
    cdf:
      args: [time: double]
      return_type: double
    icdf:
      args: [prob: double]
      return_type: double

FF16_Strategy:
  name_cpp: "plant::FF16_Strategy"
  roxygen: |
    Strategy parameters that tune various aspects of the biological model.
    @title Strategy parameters
    @param ...,values Values to initialise the struct with (either as
    variadic arguments, or as a list, but not both).
    @export
  list:
    - lma: double
    - rho: double
    - hmat: double
    - omega: double
    - eta: double
    - theta: double
    - a_l1: double
    - a_l2: double
    - a_r1: double
    - a_b1: double
    - r_s: double
    - r_b: double
    - r_r: double
    - r_l: double
    - a_y: double
    - a_bio: double
    - k_l: double
    - k_b: double
    - k_s: double
    - k_r: double
    - a_p1: double
    - a_p2: double
    - a_f3: double
    - a_f1: double
    - a_f2: double
    - S_D: double
    - a_d0: double
    - d_I: double
    - a_dG1: double
    - a_dG2: double
    - k_I: double
    - recruitment_decay: double
    - control: "plant::Control"
    - collect_all_auxiliary: bool
    - birth_rate_x: std::vector<double>
    - birth_rate_y: std::vector<double>
    - is_variable_birth_rate: bool

FF16_Environment:
  name_cpp: "plant::FF16_Environment"
  constructor:
    args:
      - light_availability_spline_rescale_usually: bool
      - soil_number_of_depths: int
    roxygen: |
      FF16_Environment object
      @param  light_availability_spline_rescale_usually whether to rescale intervals when estimating light environment
      @param  soil_number_of_depths Number of soil layers to include
      @export
  methods:
    get_environment_at_height:
      args: [height: double]
      return_type: double
    clear:
      return_type: void
    set_fixed_environment:
      args: [value: double, height_max: double]
      return_type: void
    set_soil_water_state:
      args: [state: "std::vector<double>"]
      return_type: void
    compute_rates:
      args: [resource_depletion: "std::vector<double>"]
      return_type: void
  active:
    time: {type: double, access: field}
    ode_size: {type: size_t, access: member}
    soil_number_of_depths: {type: size_t, access: member, name_cpp: ode_size}
    light_availability:
      type: "plant::ResourceSpline"
      access: field
    soil:
      type: "plant::Internals"
      access: member
      name_cpp: "r_internals"
    extrinsic_drivers: # this actually exists in the base class, not in the derived environment classes
      type: "plant::ExtrinsicDrivers"
      access: field

# The following strategy was built from FF16 on Wed Aug 12 11:12:34 2020
FF16r_Strategy:
  name_cpp: "plant::FF16r_Strategy"
  roxygen: |
    Strategy parameters that tune various aspects of the biological model.
    @title Strategy parameters
    @param ...,values Values to initialise the struct with (either as
    variadic arguments, or as a list, but not both).
    @export
  list:
    - lma: double
    - rho: double
    - hmat: double
    - omega: double
    - eta: double
    - theta: double
    - a_l1: double
    - a_l2: double
    - a_r1: double
    - a_b1: double
    - r_s: double
    - r_b: double
    - r_r: double
    - r_l: double
    - a_y: double
    - a_bio: double
    - k_l: double
    - k_b: double
    - k_s: double
    - k_r: double
    - a_p1: double
    - a_p2: double
    - a_f3: double
    - a_f1: double
    - a_f2: double
    - S_D: double
    - a_d0: double
    - d_I: double
    - a_dG1: double
    - a_dG2: double
    - k_I: double
    - recruitment_decay: double
    - control: "plant::Control"
    - collect_all_auxiliary: bool
    - birth_rate_x: std::vector<double>
    - birth_rate_y: std::vector<double>
    - is_variable_birth_rate: bool

# The following strategy was built from FF16r on Wed Aug 12 15:33:08 2020
K93_Strategy:
  name_cpp: "plant::K93_Strategy"
  roxygen: |
    Strategy parameters that tune various aspects of the biological model.
    @title Strategy parameters
    @param ...,values Values to initialise the struct with (either as
    variadic arguments, or as a list, but not both).
    @export
  list:
    - height_0: double
    - b_0: double
    - b_1: double
    - b_2: double
    - c_0: double
    - c_1: double
    - d_0: double
    - d_1: double
    - S_D: double
    - eta: double
    - k_I: double
    - control: "plant::Control"
    - birth_rate_x: std::vector<double>
    - birth_rate_y: std::vector<double>
    - is_variable_birth_rate: bool

# The following environment was built from FF16r on Wed Aug 12 15:46:38 2020
K93_Environment:
  name_cpp: "plant::K93_Environment"
  constructor:
    roxygen: |
      K93_Environment object
      @export
  methods:
    get_environment_at_height:
      args: [height: double]
      return_type: double
    clear:
      return_type: void
    set_fixed_environment:
      args: [value: double, height_max: double]
      return_type: void
  active:
    time: {type: double, access: field}
    light_availability: {type: "plant::ResourceSpline", access: field}
    ode_size: {type: size_t, access: member}


ExtrinsicDrivers:
  name_cpp: "plant::ExtrinsicDrivers"
  methods:
    evaluate:
      return_type: double
      args: [driver_name: std::string, u: double]
    evaluate_range:
      return_type: std::vector<double>
      args: [ driver_name: std::string, u: std::vector<double>]
    get_names:
      return_type: std::vector<std::string>
    set_constant:
      return_type: void
      args: [ driver_name: std::string, k: double]
    set_variable:
      return_type: void
      args: [ driver_name: std::string, x: std::vector<double>, y: std::vector<double> ]
    set_extrapolate:
      return_type: void
      args: [ driver_name: std::string, extrapolate: bool]

# The following strategy was built from FF16 on Mon Feb 12 09:52:27 2024
TF24_Strategy:
  name_cpp: "plant::TF24_Strategy"
  roxygen: |
    Strategy parameters that tune various aspects of the biological model.
    @title Strategy parameters
    @param ...,values Values to initialise the struct with (either as
    variadic arguments, or as a list, but not both).
    @export
  list:
    - lma: double
    - rho: double
    - hmat: double
    - omega: double
    - eta: double
    - theta: double
    - a_l1: double
    - a_l2: double
    - a_r1: double
    - a_b1: double
    - r_s: double
    - r_b: double
    - r_r: double
    - r_l: double
    - a_y: double
    - a_bio: double
    - k_l: double
    - k_b: double
    - k_s: double
    - k_r: double
    - a_p1: double
    - a_p2: double
    - a_f3: double
    - a_f1: double
    - a_f2: double
    - S_D: double
    - a_d0: double
    - d_I: double
    - a_dG1: double
    - a_dG2: double
    - k_I: double
    - recruitment_decay: double
    - control: "plant::Control"
    - collect_all_auxiliary: bool
    - birth_rate_x: std::vector<double>
    - birth_rate_y: std::vector<double>
    - is_variable_birth_rate: bool

# The following environment was built from FF16 on Mon Feb 12 09:52:27 2024
TF24_Environment:
  name_cpp: "plant::TF24_Environment"
  constructor:
    args:
      - light_availability_spline_rescale_usually: bool
      - soil_number_of_depths: int
      - delta_z: double
      - soil_moist_sat: double
      - K_sat: double
      - a_psi: double
      - n_psi: double
      - b_infil: double
    roxygen: |
      TF24_Environment object
      @param  light_availability_spline_rescale_usually whether to rescale intervals when estimating light environment
      @param  soil_number_of_depths Number of soil layers to include
      @export
  methods:
    get_environment_at_height:
      args: [height: double]
      return_type: double
    clear:
      return_type: void
    set_fixed_environment:
      args: [value: double, height_max: double]
      return_type: void
    psi_from_soil_moist:
      args: [theta_: double]
      return_type: double 
    soil_moist_from_psi:
      args: [psi_soil_: double]
      return_type: double
    set_soil_water_state:
      args: [state: "std::vector<double>"]
      return_type: void
    get_soil_water_state:
      args: []
      return_type: std::vector<double>
    get_atm_vpd:
      args: []
      return_type: double
    get_ca:
      args: []
      return_type: double
    get_leaf_temp:
      args: []
      return_type: double
    get_atm_o2_kpa:
      args: []
      return_type: double
    get_atm_kpa:
      args: []
      return_type: double

    compute_rates:
      args: [resource_depletion: "std::vector<double>"]
      return_type: void
  active:
    time: {type: double, access: field}
    ode_size: {type: size_t, access: member}
    soil_number_of_depths: {type: size_t, access: member, name_cpp: ode_size}
    light_availability:
      type: "plant::ResourceSpline"
      access: field
    soil:
      type: "plant::Internals"
      access: member
      name_cpp: "r_internals"
    extrinsic_drivers: # this actually exists in the base class, not in the derived environment classes
      type: "plant::ExtrinsicDrivers"
      access: field